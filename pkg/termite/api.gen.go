//go:build go1.22

// Package termite provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package termite

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/antflydb/antfly-go/libaf/chunking"
	externalRef1 "github.com/antflydb/antfly-go/libaf/logging"
	externalRef2 "github.com/antflydb/antfly-go/libaf/s3"
	externalRef3 "github.com/antflydb/antfly-go/libaf/scraping"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConfigModelStrategies.
const (
	ConfigModelStrategiesBounded ConfigModelStrategies = "bounded"
	ConfigModelStrategiesEager   ConfigModelStrategies = "eager"
	ConfigModelStrategiesLazy    ConfigModelStrategies = "lazy"
)

// Defines values for FinishReason.
const (
	FinishReasonContentFilter FinishReason = "content_filter"
	FinishReasonFunctionCall  FinishReason = "function_call"
	FinishReasonLength        FinishReason = "length"
	FinishReasonStop          FinishReason = "stop"
	FinishReasonToolCalls     FinishReason = "tool_calls"
)

// Defines values for GenerateChunkObject.
const (
	GenerateChunkObjectChatCompletionChunk GenerateChunkObject = "chat.completion.chunk"
)

// Defines values for GenerateResponseObject.
const (
	GenerateResponseObjectChatCompletion GenerateResponseObject = "chat.completion"
)

// Defines values for ImageURLContentPartType.
const (
	ImageURLContentPartTypeImageUrl ImageURLContentPartType = "image_url"
)

// Defines values for RecognizerCapability.
const (
	RecognizerCapabilityAnswers   RecognizerCapability = "answers"
	RecognizerCapabilityLabels    RecognizerCapability = "labels"
	RecognizerCapabilityRelations RecognizerCapability = "relations"
	RecognizerCapabilityZeroshot  RecognizerCapability = "zeroshot"
)

// Defines values for Role.
const (
	RoleAssistant Role = "assistant"
	RoleSystem    Role = "system"
	RoleTool      Role = "tool"
	RoleUser      Role = "user"
)

// Defines values for TextContentPartType.
const (
	TextContentPartTypeText TextContentPartType = "text"
)

// Defines values for ToolType.
const (
	ToolTypeFunction ToolType = "function"
)

// Defines values for ToolCallType.
const (
	ToolCallTypeFunction ToolCallType = "function"
)

// Defines values for ToolCallDeltaType.
const (
	ToolCallDeltaTypeFunction ToolCallDeltaType = "function"
)

// Defines values for ToolChoice0.
const (
	ToolChoice0Auto     ToolChoice0 = "auto"
	ToolChoice0None     ToolChoice0 = "none"
	ToolChoice0Required ToolChoice0 = "required"
)

// Defines values for ToolChoice1Type.
const (
	ToolChoice1TypeFunction ToolChoice1Type = "function"
)

// ChatMessage defines model for ChatMessage.
type ChatMessage struct {
	// Content Message content. Supports two formats:
	// - Simple string: "Hello, how are you?"
	// - Array of content parts (OpenAI multimodal format): [{"type": "text", "text": "Hello"}]
	Content ChatMessageContent `json:"content,omitempty,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`

	// ToolCallId ID of the tool call this message is responding to (only for role=tool)
	ToolCallId string `json:"tool_call_id,omitempty,omitzero"`

	// ToolCalls Tool calls made by the assistant (only for role=assistant)
	ToolCalls []ToolCall `json:"tool_calls,omitempty,omitzero"`
}

// ChatMessageContent Message content. Supports two formats:
// - Simple string: "Hello, how are you?"
// - Array of content parts (OpenAI multimodal format): [{"type": "text", "text": "Hello"}]
type ChatMessageContent struct {
	union json.RawMessage
}

// ChatMessageContent0 Simple text content
type ChatMessageContent0 = string

// ChatMessageContent1 Array of content parts (OpenAI multimodal format)
type ChatMessageContent1 = []ContentPart

// Chunk A chunk of text with position information.
type Chunk = externalRef0.Chunk

// ChunkConfig Configuration for chunking requests to Termite API.
// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
// which includes provider selection and caching configuration.
type ChunkConfig struct {
	// MaxChunks Maximum number of chunks to return
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// Model The chunking model to use. Either 'fixed' for simple token-based chunking, or a model name from models/chunkers/{name}/.
	Model string `json:"model,omitempty,omitzero"`

	// OverlapTokens Number of overlapping tokens between chunks
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Text separator for fixed chunking
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Confidence threshold for ONNX models (0.0-1.0)
	Threshold float32 `json:"threshold,omitempty,omitzero"`
}

// ChunkRequest defines model for ChunkRequest.
type ChunkRequest struct {
	// Config Configuration for chunking requests to Termite API.
	// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
	// which includes provider selection and caching configuration.
	Config ChunkConfig `json:"config,omitempty,omitzero"`

	// Text Text to chunk
	Text string `json:"text"`
}

// ChunkResponse defines model for ChunkResponse.
type ChunkResponse struct {
	// CacheHit Whether result was served from cache
	CacheHit bool `json:"cache_hit"`

	// Chunks Array of text chunks
	Chunks []Chunk `json:"chunks"`

	// Model Chunking model actually used (may differ from requested if fallback occurred)
	Model string `json:"model"`
}

// Config defines model for Config.
type Config struct {
	// ApiUrl URL of the Termite embedding/chunking service
	ApiUrl string `json:"api_url"`

	// BackendPriority Backend priority order for model loading with optional device specifiers.
	// Format: `backend` or `backend:device` where device defaults to `auto`.
	//
	// Termite tries entries in order and uses the first available backend+device
	// combination that supports the model.
	//
	// **Backends** (depend on build tags):
	// - `go` - Pure Go inference (always available, CPU only, slowest)
	// - `onnx` - ONNX Runtime (requires -tags="onnx,ORT", fastest)
	// - `xla` - GoMLX XLA (requires -tags="xla,XLA", TPU/CUDA/CPU)
	//
	// **Devices**:
	// - `auto` - Auto-detect best available (default)
	// - `cuda` - NVIDIA CUDA GPU
	// - `coreml` - Apple CoreML (macOS only, used by ONNX)
	// - `tpu` - Google TPU (used by XLA)
	// - `cpu` - Force CPU only
	//
	// **Examples**:
	// - `["onnx", "xla", "go"]` - Try backends with auto device detection
	// - `["onnx:cuda", "xla:tpu", "onnx:cpu", "go"]` - Prefer GPU, fall back to CPU
	// - `["onnx:coreml", "go"]` - macOS with CoreML acceleration
	BackendPriority []string                           `json:"backend_priority,omitempty,omitzero"`
	ContentSecurity externalRef3.ContentSecurityConfig `json:"content_security,omitempty,omitzero"`

	// KeepAlive How long to keep models loaded in memory after last use (Ollama-compatible).
	// Models are automatically unloaded after this duration of inactivity.
	// Use Go duration format: "5m" (5 minutes), "1h" (1 hour), "0" (eager loading).
	// Defaults to "5m" (lazy loading) like Ollama. Set to "0" to explicitly enable eager loading
	// where all models are loaded at startup and never unloaded.
	KeepAlive string `json:"keep_alive,omitempty,omitzero"`

	// Log Logging configuration for Termite services
	Log externalRef1.Config `json:"log,omitempty,omitzero"`

	// MaxConcurrentRequests Maximum number of concurrent inference requests allowed.
	// Additional requests will be queued up to max_queue_size.
	// Set to 0 for unlimited (default).
	MaxConcurrentRequests int `json:"max_concurrent_requests,omitempty,omitzero"`

	// MaxLoadedModels Maximum number of models to keep loaded in memory simultaneously.
	// When this limit is reached, the least recently used model is unloaded (LRU eviction).
	// Set to 0 for unlimited (default). Only effective when keep_alive is non-zero.
	MaxLoadedModels int `json:"max_loaded_models,omitempty,omitzero"`

	// MaxMemoryMb Maximum memory (in MB) to use for loaded models.
	// When this limit is approached, least recently used models are unloaded.
	// Set to 0 for unlimited (default). This is an advisory limit - actual memory
	// usage depends on model sizes and may temporarily exceed this value.
	// Works alongside max_loaded_models for fine-grained control.
	MaxMemoryMb int `json:"max_memory_mb,omitempty,omitzero"`

	// MaxQueueSize Maximum number of requests to queue when max_concurrent_requests is reached.
	// When the queue is full, new requests receive 503 Service Unavailable with Retry-After header.
	// Set to 0 for unlimited queue (default). Only effective when max_concurrent_requests > 0.
	MaxQueueSize int `json:"max_queue_size,omitempty,omitzero"`

	// ModelStrategies Per-model loading strategy overrides. Maps model names to their loading strategy.
	// Models not in this map use the default strategy based on keep_alive:
	// - If keep_alive>0 (default "5m"): lazy loading (load on demand, unload after idle)
	// - If keep_alive="0": eager loading (load at startup, never unload)
	//
	// When a model has strategy "eager" in this map:
	// - It is loaded at startup (as part of preload)
	// - It is never unloaded, even when keep_alive>0 (pinned in memory)
	//
	// This allows mixing eager and lazy models in the same pool.
	ModelStrategies map[string]ConfigModelStrategies `json:"model_strategies,omitempty,omitzero"`

	// ModelsDir Base directory containing model subdirectories. Termite auto-discovers models from:
	// - `{models_dir}/embedders/` - Embedding models (ONNX)
	// - `{models_dir}/chunkers/` - Chunking models (ONNX)
	// - `{models_dir}/rerankers/` - Reranking models (ONNX)
	// - `{models_dir}/recognizers/` - Recognition models (ONNX)
	// - `{models_dir}/rewriters/` - Seq2Seq rewriter models (ONNX)
	//
	// Defaults to ~/.termite/models (set via viper). If not set, only built-in fixed chunking is available.
	ModelsDir string `json:"models_dir,omitempty,omitzero"`

	// Preload List of model names to preload at startup (Ollama-compatible).
	// These models are loaded immediately when Termite starts, avoiding first-request latency.
	// Model names should match those in models_dir/embedders/ (e.g., "BAAI/bge-small-en-v1.5").
	// Only effective when keep_alive is non-zero (lazy loading mode).
	Preload []string `json:"preload,omitempty,omitzero"`

	// RequestTimeout Maximum time to wait for a request to complete, including queue wait time.
	// Use Go duration format: "30s", "1m", "0" (no timeout, default).
	// Requests exceeding this timeout receive 504 Gateway Timeout.
	RequestTimeout string                   `json:"request_timeout,omitempty,omitzero"`
	S3Credentials  externalRef2.Credentials `json:"s3_credentials,omitempty,omitzero"`
}

// ConfigModelStrategies defines model for Config.ModelStrategies.
type ConfigModelStrategies string

// ContentPart A content part for multimodal embedding (text or image)
type ContentPart struct {
	union json.RawMessage
}

// DecodeRequest defines model for DecodeRequest.
type DecodeRequest struct {
	// AttentionMask Optional attention mask for embeddings. Shape [sequence_length].
	AttentionMask []int `json:"attention_mask,omitempty,omitzero"`

	// Embeddings Pre-computed encoder hidden states for embedding-to-text generation.
	// Shape: [sequence_length, hidden_size] for single input.
	// When provided, the decoder generates text directly from these embeddings
	// without running the encoder. Mutually exclusive with 'prompt'.
	Embeddings [][]float32 `json:"embeddings,omitempty,omitzero"`

	// MaxTokens Maximum number of tokens to generate (default 256)
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Model Name of T5Gemma-2 or compatible decoder model
	Model string `json:"model"`

	// Prompt Input prompt for text generation (mutually exclusive with embeddings)
	Prompt string `json:"prompt,omitempty,omitzero"`

	// SequenceLength The sequence length of the embeddings (for reshaping flat arrays)
	SequenceLength int `json:"sequence_length,omitempty,omitzero"`

	// Temperature Sampling temperature (default 1.0)
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// TopP Nucleus sampling probability (default 1.0)
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// DecodeResponse defines model for DecodeResponse.
type DecodeResponse struct {
	// Model Name of model used for decoding
	Model string `json:"model"`

	// Texts Generated text sequences
	Texts []string `json:"texts"`

	// Tokens Token IDs for each generated sequence (optional)
	Tokens [][]int `json:"tokens,omitempty,omitzero"`
}

// EmbedRequest defines model for EmbedRequest.
type EmbedRequest struct {
	// Input Input content to embed. Supports three formats:
	// - Single text string: `"hello world"`
	// - Array of text strings: `["hello", "world"]`
	// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
	Input EmbedRequest_Input `json:"input"`

	// Model Name of the embedder model from models_dir/embedders/
	Model string `json:"model"`

	// Truncate Truncate input to fit model context length
	Truncate bool `json:"truncate,omitempty,omitzero"`
}

// EmbedRequestInput0 Single text string (backward compatible)
type EmbedRequestInput0 = string

// EmbedRequestInput1 Array of text strings (backward compatible)
type EmbedRequestInput1 = []string

// EmbedRequestInput2 Array of multimodal content parts (text or images)
type EmbedRequestInput2 = []ContentPart

// EmbedRequest_Input Input content to embed. Supports three formats:
// - Single text string: `"hello world"`
// - Array of text strings: `["hello", "world"]`
// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
type EmbedRequest_Input struct {
	union json.RawMessage
}

// EmbedResponse defines model for EmbedResponse.
type EmbedResponse struct {
	// Embeddings Array of embedding vectors (one per input string)
	Embeddings [][]float32 `json:"embeddings"`

	// Model Model used for embedding
	Model string `json:"model"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// FinishReason Reason why generation stopped
type FinishReason string

// FunctionDefinition Definition of a function that can be called by the model
type FunctionDefinition struct {
	// Description A description of what the function does
	Description string `json:"description,omitempty,omitzero"`

	// Name The name of the function to call
	Name string `json:"name"`

	// Parameters JSON Schema object describing the function parameters
	Parameters map[string]interface{} `json:"parameters,omitempty,omitzero"`

	// Strict Whether to enforce strict parameter validation
	Strict bool `json:"strict,omitempty,omitzero"`
}

// GenerateChoice defines model for GenerateChoice.
type GenerateChoice struct {
	// FinishReason Reason why generation stopped
	FinishReason FinishReason `json:"finish_reason"`

	// Index Index of this choice in the list
	Index int `json:"index"`

	// Logprobs Log probability information (not supported, always null)
	Logprobs map[string]interface{} `json:"logprobs,omitzero"`
	Message  GenerateMessage        `json:"message"`
}

// GenerateChunk Streaming generation chunk (SSE event data)
type GenerateChunk struct {
	Choices []GenerateChunkChoice `json:"choices"`
	Created int                   `json:"created"`
	Id      string                `json:"id"`
	Model   string                `json:"model"`
	Object  GenerateChunkObject   `json:"object"`
}

// GenerateChunkObject defines model for GenerateChunk.Object.
type GenerateChunkObject string

// GenerateChunkChoice defines model for GenerateChunkChoice.
type GenerateChunkChoice struct {
	// Delta Delta content for streaming
	Delta GenerateDelta `json:"delta"`

	// FinishReason Reason why generation stopped
	FinishReason FinishReason `json:"finish_reason,omitempty,omitzero"`
	Index        int          `json:"index"`
}

// GenerateDelta Delta content for streaming
type GenerateDelta struct {
	// Content Token content delta
	Content string `json:"content,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role,omitempty,omitzero"`

	// ToolCalls Tool call deltas for streaming tool calls
	ToolCalls []ToolCallDelta `json:"tool_calls,omitempty,omitzero"`
}

// GenerateMessage defines model for GenerateMessage.
type GenerateMessage struct {
	// Content The generated message content (null when tool_calls is present)
	Content string `json:"content,omitzero"`

	// Role The role of a message sender in a conversation
	Role Role `json:"role"`

	// ToolCalls Tool calls made by the model (only present when finish_reason is tool_calls)
	ToolCalls []ToolCall `json:"tool_calls,omitempty,omitzero"`
}

// GenerateRequest defines model for GenerateRequest.
type GenerateRequest struct {
	// MaxTokens Maximum tokens to generate
	MaxTokens int `json:"max_tokens,omitempty,omitzero"`

	// Messages Conversation messages (OpenAI-compatible format)
	Messages []ChatMessage `json:"messages"`

	// Model Name of the generator model from models_dir/generators/
	Model string `json:"model"`

	// Stream If true, partial message deltas will be sent as SSE events
	Stream bool `json:"stream,omitempty,omitzero"`

	// Temperature Sampling temperature (0.0 = deterministic, higher = more random)
	Temperature float32 `json:"temperature,omitempty,omitzero"`

	// ToolChoice Controls how the model uses tools. Options:
	// - "auto": Model decides whether to call a tool (default)
	// - "none": Model will not call any tools
	// - "required": Model must call at least one tool
	// - object: Force a specific function to be called
	ToolChoice ToolChoice `json:"tool_choice,omitempty,omitzero"`

	// Tools List of tools (functions) the model can call.
	// Only supported by models with tool_call_format configured.
	Tools []Tool `json:"tools,omitempty,omitzero"`

	// TopK Top-k sampling (Termite extension, not in OpenAI API)
	TopK int `json:"top_k,omitempty,omitzero"`

	// TopP Nucleus sampling probability
	TopP float32 `json:"top_p,omitempty,omitzero"`
}

// GenerateResponse OpenAI-compatible chat completion response
type GenerateResponse struct {
	// Choices List of completion choices (currently always 1)
	Choices []GenerateChoice `json:"choices"`

	// Created Unix timestamp (seconds) when the completion was created
	Created int `json:"created"`

	// Id A unique identifier for the chat completion
	Id string `json:"id"`

	// Model Model used for generation
	Model string `json:"model"`

	// Object The object type, always "chat.completion"
	Object GenerateResponseObject `json:"object"`
	Usage  GenerateUsage          `json:"usage"`
}

// GenerateResponseObject The object type, always "chat.completion"
type GenerateResponseObject string

// GenerateUsage defines model for GenerateUsage.
type GenerateUsage struct {
	// CompletionTokens Number of tokens in the completion
	CompletionTokens int `json:"completion_tokens"`

	// PromptTokens Number of tokens in the prompt
	PromptTokens int `json:"prompt_tokens"`

	// TotalTokens Total tokens used (prompt + completion)
	TotalTokens int `json:"total_tokens"`
}

// ImageURL Image URL or data URI
type ImageURL struct {
	// Url URL or data URI (data:image/png;base64,...)
	Url string `json:"url"`
}

// ImageURLContentPart Image content for embedding (OpenAI-compatible format)
type ImageURLContentPart struct {
	// ImageUrl Image URL or data URI
	ImageUrl ImageURL                `json:"image_url"`
	Type     ImageURLContentPartType `json:"type"`
}

// ImageURLContentPartType defines model for ImageURLContentPart.Type.
type ImageURLContentPartType string

// ModelsResponse defines model for ModelsResponse.
type ModelsResponse struct {
	// Chunkers Available chunking models (always includes "fixed")
	Chunkers []string `json:"chunkers"`

	// Embedders Available embedding models from models_dir/embedders/
	Embedders []string `json:"embedders"`

	// Extractors Available GLiNER extractor models (zero-shot recognition with custom labels)
	Extractors []string `json:"extractors,omitempty,omitzero"`

	// Generators Available generator/LLM models from models_dir/generators/
	Generators []string `json:"generators"`

	// RecognizerInfo Detailed information about recognizer models including capabilities.
	// Map of model name to model info. Use this to determine what capabilities
	// each recognizer supports (labels, zeroshot, relations, answers).
	RecognizerInfo map[string]RecognizerModelInfo `json:"recognizer_info,omitempty,omitzero"`

	// Recognizers Available recognizer models from models_dir/recognizers/
	Recognizers []string `json:"recognizers"`

	// Rerankers Available reranking models
	Rerankers []string `json:"rerankers"`

	// Rewriters Available Seq2Seq rewriter models from models_dir/rewriters/
	Rewriters []string `json:"rewriters"`
}

// RecognizeEntity defines model for RecognizeEntity.
type RecognizeEntity struct {
	// End Character offset where entity ends (exclusive)
	End int `json:"end"`

	// Label Entity type (PER, ORG, LOC, MISC)
	Label string `json:"label"`

	// Score Confidence score (0.0 to 1.0)
	Score float32 `json:"score"`

	// Start Character offset where entity begins
	Start int `json:"start"`

	// Text The entity text
	Text string `json:"text"`
}

// RecognizeRequest defines model for RecognizeRequest.
type RecognizeRequest struct {
	// Labels Custom entity labels to extract (GLiNER models only).
	// When using a GLiNER model, you can specify any entity types to extract,
	// enabling zero-shot NER without model retraining.
	// If not provided, the model's default labels are used.
	Labels []string `json:"labels,omitempty,omitzero"`

	// Model Name of recognizer model from models_dir/recognizers/
	Model string `json:"model"`

	// RelationLabels Relation types to extract (for models with 'relations' capability).
	// Only used when the model supports relation extraction (GLiNER multitask, REBEL).
	// If not provided, the model extracts all relations it can detect.
	RelationLabels []string `json:"relation_labels,omitempty,omitzero"`

	// Texts Texts to extract entities from
	Texts []string `json:"texts"`
}

// RecognizeResponse defines model for RecognizeResponse.
type RecognizeResponse struct {
	// Entities Array of entity arrays (one per input text)
	Entities [][]RecognizeEntity `json:"entities"`

	// Model Name of model used for NER
	Model string `json:"model"`

	// Relations Array of relation arrays (one per input text).
	// Only present when using a model with 'relations' capability (GLiNER multitask, REBEL).
	Relations [][]Relation `json:"relations,omitempty,omitzero"`
}

// RecognizerCapability Capability that a recognizer model supports:
// - labels: Entity extraction (NER) - extracts labeled spans like PER, ORG, LOC
// - zeroshot: Supports arbitrary labels at inference time (GLiNER models)
// - relations: Relation extraction between entities (GLiNER multitask, REBEL)
// - answers: Extractive question answering (GLiNER multitask)
type RecognizerCapability string

// RecognizerModelInfo Detailed information about a recognizer model
type RecognizerModelInfo struct {
	// Capabilities List of capabilities this recognizer model supports
	Capabilities []RecognizerCapability `json:"capabilities,omitempty,omitzero"`
}

// Relation defines model for Relation.
type Relation struct {
	Head RecognizeEntity `json:"head"`

	// Label The relationship type
	Label string `json:"label"`

	// Score Confidence score for the relation (0.0 to 1.0)
	Score float32         `json:"score"`
	Tail  RecognizeEntity `json:"tail"`
}

// RerankRequest defines model for RerankRequest.
type RerankRequest struct {
	// Model Name of reranking model from models_dir/rerankers/
	Model string `json:"model"`

	// Prompts Pre-rendered document texts to rerank. The client is responsible for extracting
	// and rendering document fields/templates before calling this endpoint.
	Prompts []string `json:"prompts"`

	// Query Search query for relevance scoring
	Query string `json:"query"`
}

// RerankResponse defines model for RerankResponse.
type RerankResponse struct {
	// Model Name of model used for reranking
	Model string `json:"model"`

	// Scores Relevance scores (one per prompt, same order as input)
	Scores []float32 `json:"scores"`
}

// RewriteRequest defines model for RewriteRequest.
type RewriteRequest struct {
	// Inputs Input texts to rewrite/transform
	Inputs []string `json:"inputs"`

	// Model Name of Seq2Seq rewriter model from models_dir/rewriters/
	Model string `json:"model"`
}

// RewriteResponse defines model for RewriteResponse.
type RewriteResponse struct {
	// Model Name of model used for rewriting
	Model string `json:"model"`

	// Texts Rewritten texts (array of arrays, one per input, multiple per beam)
	Texts [][]string `json:"texts"`
}

// Role The role of a message sender in a conversation
type Role string

// TextContentPart Text content for embedding
type TextContentPart struct {
	// Text Text content to embed
	Text string              `json:"text"`
	Type TextContentPartType `json:"type"`
}

// TextContentPartType defines model for TextContentPart.Type.
type TextContentPartType string

// Tool A tool (function) that the model can call
type Tool struct {
	// Function Definition of a function that can be called by the model
	Function FunctionDefinition `json:"function"`

	// Type The type of tool (currently only "function" is supported)
	Type ToolType `json:"type"`
}

// ToolType The type of tool (currently only "function" is supported)
type ToolType string

// ToolCall A tool call made by the model
type ToolCall struct {
	// Function The function called by the model
	Function ToolCallFunction `json:"function"`

	// Id Unique identifier for this tool call
	Id string `json:"id"`

	// Type The type of tool call (currently only "function")
	Type ToolCallType `json:"type"`
}

// ToolCallType The type of tool call (currently only "function")
type ToolCallType string

// ToolCallDelta Incremental tool call data for streaming
type ToolCallDelta struct {
	// Function Incremental function call data for streaming
	Function ToolCallFunctionDelta `json:"function,omitempty,omitzero"`

	// Id Unique identifier (only in first delta for this index)
	Id string `json:"id,omitempty,omitzero"`

	// Index Index of the tool call in the array
	Index int `json:"index,omitempty,omitzero"`

	// Type The type of tool call (only in first delta)
	Type ToolCallDeltaType `json:"type,omitempty,omitzero"`
}

// ToolCallDeltaType The type of tool call (only in first delta)
type ToolCallDeltaType string

// ToolCallFunction The function called by the model
type ToolCallFunction struct {
	// Arguments JSON string of the arguments to the function
	Arguments string `json:"arguments"`

	// Name The name of the function called
	Name string `json:"name"`
}

// ToolCallFunctionDelta Incremental function call data for streaming
type ToolCallFunctionDelta struct {
	// Arguments Incremental arguments JSON string
	Arguments string `json:"arguments,omitempty,omitzero"`

	// Name Function name (only in first delta)
	Name string `json:"name,omitempty,omitzero"`
}

// ToolChoice Controls how the model uses tools. Options:
// - "auto": Model decides whether to call a tool (default)
// - "none": Model will not call any tools
// - "required": Model must call at least one tool
// - object: Force a specific function to be called
type ToolChoice struct {
	union json.RawMessage
}

// ToolChoice0 defines model for ToolChoice.0.
type ToolChoice0 string

// ToolChoice1 Force a specific function to be called
type ToolChoice1 struct {
	Function struct {
		// Name The name of the function to call
		Name string `json:"name"`
	} `json:"function"`
	Type ToolChoice1Type `json:"type"`
}

// ToolChoice1Type defines model for ToolChoice.1.Type.
type ToolChoice1Type string

// VersionResponse defines model for VersionResponse.
type VersionResponse struct {
	// BuildTime Build timestamp
	BuildTime string `json:"build_time"`

	// GitCommit Git commit hash
	GitCommit string `json:"git_commit"`

	// GoVersion Go runtime version
	GoVersion string `json:"go_version"`

	// Version Termite version
	Version string `json:"version"`
}

// ChunkTextJSONRequestBody defines body for ChunkText for application/json ContentType.
type ChunkTextJSONRequestBody = ChunkRequest

// DecodeTextJSONRequestBody defines body for DecodeText for application/json ContentType.
type DecodeTextJSONRequestBody = DecodeRequest

// GenerateEmbeddingsJSONRequestBody defines body for GenerateEmbeddings for application/json ContentType.
type GenerateEmbeddingsJSONRequestBody = EmbedRequest

// GenerateContentJSONRequestBody defines body for GenerateContent for application/json ContentType.
type GenerateContentJSONRequestBody = GenerateRequest

// RecognizeEntitiesJSONRequestBody defines body for RecognizeEntities for application/json ContentType.
type RecognizeEntitiesJSONRequestBody = RecognizeRequest

// RerankPromptsJSONRequestBody defines body for RerankPrompts for application/json ContentType.
type RerankPromptsJSONRequestBody = RerankRequest

// RewriteTextJSONRequestBody defines body for RewriteText for application/json ContentType.
type RewriteTextJSONRequestBody = RewriteRequest

// AsChatMessageContent0 returns the union data inside the ChatMessageContent as a ChatMessageContent0
func (t ChatMessageContent) AsChatMessageContent0() (ChatMessageContent0, error) {
	var body ChatMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageContent0 overwrites any union data inside the ChatMessageContent as the provided ChatMessageContent0
func (t *ChatMessageContent) FromChatMessageContent0(v ChatMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageContent0 performs a merge with any union data inside the ChatMessageContent, using the provided ChatMessageContent0
func (t *ChatMessageContent) MergeChatMessageContent0(v ChatMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatMessageContent1 returns the union data inside the ChatMessageContent as a ChatMessageContent1
func (t ChatMessageContent) AsChatMessageContent1() (ChatMessageContent1, error) {
	var body ChatMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMessageContent1 overwrites any union data inside the ChatMessageContent as the provided ChatMessageContent1
func (t *ChatMessageContent) FromChatMessageContent1(v ChatMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMessageContent1 performs a merge with any union data inside the ChatMessageContent, using the provided ChatMessageContent1
func (t *ChatMessageContent) MergeChatMessageContent1(v ChatMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatMessageContent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatMessageContent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextContentPart returns the union data inside the ContentPart as a TextContentPart
func (t ContentPart) AsTextContentPart() (TextContentPart, error) {
	var body TextContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContentPart overwrites any union data inside the ContentPart as the provided TextContentPart
func (t *ContentPart) FromTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContentPart performs a merge with any union data inside the ContentPart, using the provided TextContentPart
func (t *ContentPart) MergeTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageURLContentPart returns the union data inside the ContentPart as a ImageURLContentPart
func (t ContentPart) AsImageURLContentPart() (ImageURLContentPart, error) {
	var body ImageURLContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageURLContentPart overwrites any union data inside the ContentPart as the provided ImageURLContentPart
func (t *ContentPart) FromImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageURLContentPart performs a merge with any union data inside the ContentPart, using the provided ImageURLContentPart
func (t *ContentPart) MergeImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmbedRequestInput0 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput0
func (t EmbedRequest_Input) AsEmbedRequestInput0() (EmbedRequestInput0, error) {
	var body EmbedRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput0 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput0
func (t *EmbedRequest_Input) FromEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput0 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput0
func (t *EmbedRequest_Input) MergeEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput1 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput1
func (t EmbedRequest_Input) AsEmbedRequestInput1() (EmbedRequestInput1, error) {
	var body EmbedRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput1 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput1
func (t *EmbedRequest_Input) FromEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput1 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput1
func (t *EmbedRequest_Input) MergeEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput2 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput2
func (t EmbedRequest_Input) AsEmbedRequestInput2() (EmbedRequestInput2, error) {
	var body EmbedRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput2 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput2
func (t *EmbedRequest_Input) FromEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput2 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput2
func (t *EmbedRequest_Input) MergeEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbedRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmbedRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsToolChoice0 returns the union data inside the ToolChoice as a ToolChoice0
func (t ToolChoice) AsToolChoice0() (ToolChoice0, error) {
	var body ToolChoice0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoice0 overwrites any union data inside the ToolChoice as the provided ToolChoice0
func (t *ToolChoice) FromToolChoice0(v ToolChoice0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoice0 performs a merge with any union data inside the ToolChoice, using the provided ToolChoice0
func (t *ToolChoice) MergeToolChoice0(v ToolChoice0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsToolChoice1 returns the union data inside the ToolChoice as a ToolChoice1
func (t ToolChoice) AsToolChoice1() (ToolChoice1, error) {
	var body ToolChoice1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoice1 overwrites any union data inside the ToolChoice as the provided ToolChoice1
func (t *ToolChoice) FromToolChoice1(v ToolChoice1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoice1 performs a merge with any union data inside the ToolChoice, using the provided ToolChoice1
func (t *ToolChoice) MergeToolChoice1(v ToolChoice1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ToolChoice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ToolChoice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Chunk text into smaller segments
	// (POST /chunk)
	ChunkText(w http.ResponseWriter, r *http.Request)
	// Decode text from embeddings using T5Gemma-2
	// (POST /decode)
	DecodeText(w http.ResponseWriter, r *http.Request)
	// Generate embeddings
	// (POST /embed)
	GenerateEmbeddings(w http.ResponseWriter, r *http.Request)
	// Generate text using LLM (OpenAI-compatible)
	// (POST /generate)
	GenerateContent(w http.ResponseWriter, r *http.Request)
	// List available models
	// (GET /models)
	ListModels(w http.ResponseWriter, r *http.Request)
	// Recognize named entities
	// (POST /recognize)
	RecognizeEntities(w http.ResponseWriter, r *http.Request)
	// Rerank prompts by relevance
	// (POST /rerank)
	RerankPrompts(w http.ResponseWriter, r *http.Request)
	// Rewrite text using Seq2Seq models
	// (POST /rewrite)
	RewriteText(w http.ResponseWriter, r *http.Request)
	// Get version information
	// (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ChunkText operation middleware
func (siw *ServerInterfaceWrapper) ChunkText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChunkText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DecodeText operation middleware
func (siw *ServerInterfaceWrapper) DecodeText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DecodeText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateEmbeddings operation middleware
func (siw *ServerInterfaceWrapper) GenerateEmbeddings(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateEmbeddings(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateContent operation middleware
func (siw *ServerInterfaceWrapper) GenerateContent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateContent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModels operation middleware
func (siw *ServerInterfaceWrapper) ListModels(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModels(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecognizeEntities operation middleware
func (siw *ServerInterfaceWrapper) RecognizeEntities(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecognizeEntities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RerankPrompts operation middleware
func (siw *ServerInterfaceWrapper) RerankPrompts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RerankPrompts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RewriteText operation middleware
func (siw *ServerInterfaceWrapper) RewriteText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RewriteText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/chunk", wrapper.ChunkText)
	m.HandleFunc("POST "+options.BaseURL+"/decode", wrapper.DecodeText)
	m.HandleFunc("POST "+options.BaseURL+"/embed", wrapper.GenerateEmbeddings)
	m.HandleFunc("POST "+options.BaseURL+"/generate", wrapper.GenerateContent)
	m.HandleFunc("GET "+options.BaseURL+"/models", wrapper.ListModels)
	m.HandleFunc("POST "+options.BaseURL+"/recognize", wrapper.RecognizeEntities)
	m.HandleFunc("POST "+options.BaseURL+"/rerank", wrapper.RerankPrompts)
	m.HandleFunc("POST "+options.BaseURL+"/rewrite", wrapper.RewriteText)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersion)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9C28bN5foX+HVd4HY3dHDdpKmuigWjuPk866T+LOdr90bGTI1Q0msR+R0yLGtFr6/",
	"/YLnkBzOS5aTprvYLVCgsYbPw8Pz4nn83ovlKpOCCa164997Kl6yFYV/Hi2pfs+Uogtm/sxymbFccwYf",
	"Yyk0E9r883/nbN4b9/42LEca2mGGwRhHtsdD1Mtlyh7reW7aPEQ9LWU6jWmaTnli+iRMxTnPNJeiN+6d",
	"vCFyTvSSEdOOmHZEL7kiK5yUcEVypjIpEi4WREuyI0W6JnOZE7OKH0233V7U0+uM9cY9pXMuFpV5VXPW",
	"SzeXIiuaMDJbwxKoUlxpKnR9Ev/BzMQ1W6nHdm9mOKJpCivBpdE8p+vegwEf+7XgOUt6488IyivfSM5+",
	"YTHAuAXyjX3Y78Qe5oBcFFkmc62IvpNm+Suq1Xgi+uSCr7KUEQTPmEx6f2dpKiOylHeE5oysZfGvk55p",
	"eWiWaQ7FDkoyagbc+ZgxcXhCVkWq+UomNLXj747J598nsP5Jz4ys2b2e9CL/Lz/bpPdwNRG9qCcF+zjv",
	"jT/Xt2MXabq52VtOtt7ryQve9gwt2M9orpvHeAVHVIib5qkckth8AMQ2W7njekkyqbj5TrjAZXApBr2o",
	"diuZSKbxkubNQY+WNKexZnk4EpE5X3BBUzvRkuXMTs5EosgOu4/TQvFbFlwRLjRbsNxsqe1GXrBfCyZi",
	"RkSxmrHcXU8cdWcUkb2I7EdkMBi0jBn17vsL2be/Flzog30zkdI013/QzmAs1bof07bltvvldyJV7VLy",
	"pGcHqyw9Ks+n/cYW4uZIijlftOwSfi9yOHigLLAkQ9TMzEyZSyvJJctXXDNyeHYymIhLQwm5IpQoczX4",
	"nLPEbGLOFzCEOZi/X16emeakTxI+n7NckXkuV/BtXqQpgWWxHBcwEXdLHi8JF3FaJEyRLJe3PGE5USxl",
	"MSyOioTENF6atcXhsgdwe6sYu6L3U9iJJbNzWqS6N34xiuq0it7zVbEK0Aq7mV3nTBe5GZvdU0MCsH/z",
	"fFcyYWllnt6c3zNzWh1HbvYAvcw0hWIDcsz1kuXkGXR8BmBUlu7IGyb6M6oMkG3niMicUDuEoCuGwIW/",
	"1TBG0Krh7+bTw3AQbsEvrcGa5C3LU5pNYcLH4PbBw8t2y5ARmq5kxvQdY8KC8nEAKpbRnGqZV4E4EXCy",
	"NRiai+c7AKBgRx42lc3aIZpsmOYLptu32tjrJTQOKQ9uM2P2ulR32LpFvcyZWso0qUw2GryI2m5kAqTO",
	"94Fdfvzw4Wd7wmRnNBj19waj3XBmGAypuDnmVNKApODigaS0U4hzvO6tIpklHZslspLKdJM8c3ZaNoHW",
	"K0lKKsWCJDIuVoZp6iXVRDCWwIWcMaKylGvChZZErWiauiNQg8HgUQIKq7rqhoAR6BSIkH5lv/cMzWHT",
	"Jde98ZymikU9R1g+h5xxz5y74VyjKl8ZOWD4PQIJ5LnSuHKzcCM+BEP9YIfaqw71Q/tYisVSJMFgV54k",
	"2cv+UCePwZ7qZ/TTkgElypkqUk3uqCKK5bcsQRIDPUtAz6RMGRVmhpDctgpCKEA5krCdrAOI0pByKiS3",
	"yrQrxJXGuqBpujYkNiE7K7q2zAj3YjkcSwifkzlN0xmNb4iM4yLPWbK7DdWsIZjfHa4vCgDdinb+alWP",
	"h2Z8WuQt+/t0fuokH8eS2WrGEqOFDD1nMefFY1ZZ/1LrbDwcpjKm6VIqPX41ejXqBfSiyHkboTQgMZiZ",
	"5VzmXK8r5OtzTwpxb8SrlPai3kKaXVZX/Br7E9efyNywdUPQ8IxSSUGHAnFUQjeakoSZHRCVsdiIF7ka",
	"TMRbWOqYXNs1XRsm6P4YY49rK5PZ/nalQDyuaaHl9cBwBAc7nXOmCBP4fxDvzOKMpFEoFt5Uekt5Smcp",
	"I3a+f8EZJiKWqxkXKD8BtVJe2Vky3CPM+d13FhTqu+/ITsIyAxUpyKzgaUI0XahdUImuF/Ka9MlZkTPy",
	"Thq5nOXADXZoekfXqlxKRI7OPhGjEkZEpfKOKb0LI5hDMWMAxzgvhOYrRnYsnirSN5P9OIGziz6eXxqt",
	"aE6V9v3vU2q6v5PvT38mP58etvS9T2n08+mh6Xp59ml49OnN4fDo7NMu7vQNwEZ99x3uCABP+uSw0LKf",
	"MM1iTWasAtUde1K4gLhIYAUf/nny5uSQmNHJu7NP+E3mbJXCcJkRj45kzt6fmssdf7yw0IDrPlsDAHBE",
	"nRW4JblImVky2XGNfj49tLNim7cyj5kHLW7oGO+R39FnhB7qk/cpxX8s5KR3ZYa4zNcOTxQitgFBiZQa",
	"RdpwqLHZsx9vrLMC/8Bv7i8/w1nODBl7d/YpAsoF0xksP7Jg8sMCuGq9EVawMAs+GscsZShPTyoi7+dy",
	"eXjRzdpAW8aF2R/xX0gBPGlvil01Mm41n6liceGoyyZ+QIWep+v+Qk5TPqPzqYpzagTPqcyYMFTTKscX",
	"drxSILlhLJvSlN+yqoz5YtWQMP8u71AK0ZKYbk7oMpTK8ApBVmwl8zWhc6MeplRpg3Fk52Oa0hXtm3VT",
	"zWcp2x1MxHvsTHMGSGBU7Bh5krAD4jBgXkqcJibnhAsaa37L9XowEZ8UUIMk0NSAFk56L1aTHtl5QVZc",
	"FJqpXXPQe0vz2x5ZyiKHH0bmb0YXZrlIb83S3gTU0Q2U0t/Wvg1J+Q0juK0BuWAaW5rRtCTsPkt5zHW6",
	"JkzALa7MYHQ6Q4oNdq5KILhNa9SYiwzIrWC3LPcgGVRREA+pgUypXDwVX1K5WNTQxeIHKIxSAOsXeuqU",
	"36q0voXy6IcIKLfXpGlqyLTZ3mGScMvq/Nc7bu4xI78WrGAJKTIDZLMu+GGq+G9sMBH2FEbAQguRcsPJ",
	"kpKA1mD3vFVhpfdThPQUT+ap27Tn6S5I42YovipSTQWThUoN/v60ZAJRHBaM9lMjGyUR8MmUmVuUs5gJ",
	"7eQ1lA+4Km/Kzun5J2KIqFnY7jbAIB+FQc/53FDcW2akA0FKWmBGF1L0f2O5rAHuoAtwuMXparYd0CxE",
	"drgg71/vWn0f1ms3hbBshxHNslxaMHWCCO9VcHceh4pXtwShyS1XZoU4ad8KzXbdE1GAKRflFWUEFjwW",
	"g40Krq6RqjVbZTKnOTfAvo8ZS3AjtzQtDNL+JPMbg/5SLBRPGGkgoNXjBesvcsoF2pN0LtM6Oo9+eNl1",
	"MOU1eSo6h6YuGAXxpIMmBMhbnpq9tubbvEjTiAh2V45rTs2g24vRAblA6Zx8EqX4A6z4nOl83T8EbrBk",
	"NGF591niZI/gedf6J8VodMDIqAbbvVG3dWuqdE41WzgFxZOvs5qhuFgZkQEYQS/qGW7Si3ozWYiEJYEO",
	"VFLx6tmcsbxf1QvsxGuwM+U8YWpA3tNMBcYvODe9ZDxv9CoZsJCGJNtXHJrBLTTHZkFYzoOWNhmSCRD6",
	"TubBLwjCkT8Byz93xyRkoGTH/MOMlbAVFUlkb6ll+TxJ2W5j6B+BwY6rzNSOVHLNqMIyQe4GTHRGwaXR",
	"292WJnggk14IAdwUkJkmT96hCh4szO3IcmbncO2r3Doi7JaJOmn1EMq4ECFzgLUCAQJ2qMiK35sd4n4N",
	"RQEQWrrA8XIpumIkkw168Hvv9eHhyXC2YH0wB/WZ6N/uDV70xh4HVzzXy2G8lOJm3V+ZK69tW3iDSblY",
	"FDTt7/XGiK5tFjJczDThLQ8Fr6liJOE5i7Uho4ZuUS5KI4QqZu4rN8jrlE8K2hBXsUFs5fY7z+UKdYzf",
	"y0kfhqjls1wNjfx+7HR+bw8sNZ1KN28JNr2qxpHuTjnLadnrHP7aqlssF4L/VnaEv0FcfbTrXc6163jB",
	"ft2/YL8S92u9d1Vw/X/DgUaIDl07xTS55ZTc8ozluwNzvcztV0xHoNOBzq37XNQsx8ARHU2uy6CNedpE",
	"UntVmkhyypX2glNJtGz7ys1r1SIul0yxFjGar1Ys4VSzdI0X0GEXPkdFhN5KDpgCdoy+5QEkpZqJ2JNH",
	"uyK1lEVqOLqOl0QvpWJwbf1JBWhIdthgMTC6RfsFnPTMsreXvqqaB8xZF2U/d931qAfyPB/GKc/6t1zD",
	"a0k/M9s42H+aRmoBNNV8xWShq8riqNclS4CJRUtyR7kGVk0d8wd7tzQ70CyyD1xmh1bOMO1N54063sFI",
	"oQa/t8L/gz4nJLGrjEgg/Z87No+CGDzLGGpr2wayyHPyjmp2R9fkEr/Vcf5g1Irl6mAa5yxhQnOaqifr",
	"7Ael+hWMUjelOhtoh93UP4G3vXMHL+5oaSwf2725lOyAPVrmhK/oAl6iSweAjT4U7F5X3+A3tz8xw386",
	"P630uXqIem9YLBPW+e5CtWnOpZiuqGp5z//obKW+ITENYcN+l2pALpY0Y+Szsg/o05SJhV5eDXrNaxG+",
	"V9XuRTlicyVnOQNyVRjJlAmzq5wseZIwYeiQZqq6qL6WfQD+ggnm33BhnePGQiM7Egj2V/ZhVCxSQ5oy",
	"QFmQe+yDsVUnE4aLsBMYYmvmQz6crv1TtArs52oijBgOV6QQAu8Nc/sZkPeFfUzw3gsotj/LcrnK9DO8",
	"PB6k/h+Pvcg1Yd147KD3bS+V+y9ePq7a2KdKLT0sSpl1/8XLdgeMjteVD0YIk3Ny+eIdW61of9/cnpJP",
	"eai7x4+SkCzA7jrULxbYsb///WjVzkANLFscssxZE/yKPgZV/CE7q47jKc93t/biyMiKUThnOScpnxt+",
	"1EruqgjZ7snhGhFs5F5pytnJDvhtMbUEiyWZp1QTOGK12+E1ssrM7oq8qs/u1Q/9wmwJ0LXsUR6yfSXe",
	"AgtlNs02z/ShiFNWKCON44xZLmd0xlOu10+esUbvEWnaqL2jk+XrbM3XYzO2osgF5hJzAoCk6CbQFAbY",
	"vW6hb+/szUkQ69xRq95TBIvwAled/m6YICdvLI2k8dLf1KTEqh33MrbbSmMep98bvf3chcX9t50BaByd",
	"rAoocdelddxYS7wNoTvgMmes5hAIpB3hbL0Crye9JUtTSe5kniaT3nXFHzBoqsbw7rFErz4jJ9keV9eb",
	"XAhL6WDXDPCo16Ad/yEilaYgRhiRBdsHf45NQ/uvSS+hmo7h6zATi/9jRNWXz6PBYDDpPTyYlVZl3mDr",
	"RpkFByiwl+aGdJnD6vZbrMOS7MxofHNH8yQg27tPcWYMod052taXonOaQGCrHVZFaFN/nNPkI0SkpOWO",
	"v4UeVzXdqMJnOnWWJnDyQsRUV6m9zgvW8EeyDVECMhdrzrVdFYDrXls21OKo0XH18QpvuPqtvjGhVPj5",
	"82gw2ts/iPqjwej5i5fRaDD6/tUPV5H5ff/gOfz+4uX35vdXP1wFTiodIGp4rWySQT3qlAL+LdhcFNmR",
	"goGvFoILAb77rWS1djx6X2VCfpFfhCodRxiAp/Uc8xwd7GpAdT9XFwytnbv7o0vAQdpmfcsFV8tzRpUZ",
	"tj4L/k7ulutQllNaZhl42zh7svmlF/VKpC696MtH5DlPNVj85oWAFyJo0Wp0fmtbvGFzjiaq5trKbwat",
	"KHGjopdHTAWZMfDWRzcC7+3R8EWtDNvUVoO/zUR3ZnT0krXzJZJVfCh77xi2cC+Nd4yCyxYX4D8XAxTb",
	"KIygK9YuvoqAzpUblbC/qiTP9NTO1yq/05yumGb5hmeCNpL2bxcfP5ALINYEkcfCZeb0ML+qYIqKIbgK",
	"dA+Gdr9rI7BSkaB6GhE2WAzIBRXkbU5FzFUsI3J0+Cja+0naML/xgxkkrlqUrENhuweeEZjEHLxRsGu5",
	"dXJLU57UzrmLxMOpt63QybVHS8njFhjO4e5Oc395N3HYykV/MAwlYfdtMmHC7hHTuCIxzOyM/ClXulUV",
	"SuXCaBotZP9UVpWQIIyB7IDRF2VNlkTE+k+JIgUp2vyfzgzuIEI2jf5lkNKmjTsoupimhtc+AKIcLqrB",
	"dfPJtIZyXOic0ZW5GQHVtKEQFxfH8B6jiRE0dxvUCEFeZXvbbA8dfBFT2jx5cmY0lnZlhCet0qDnlU1X",
	"dIRE8KIYL6keWDsql2KALsRXW4VM2NHKRQb+mRYajx5C1x1JWKrptjB8A40foj/oZtUB3YF4uMRNO3zj",
	"NlHngKmmXgAHy5tDvCZadQWDoX7rBsG1dF6+EgO+KJZvU0wdTq2q2yjD+9RTQ+j8WTY0604wbxP12ORV",
	"pTVgVY2rIzsGivioUoKAcEWynCmGYYF/PqCrwYuolWDgol0WrrhyBcCV3Q/+J4YzuqPpNG083fbatLiG",
	"cgp0bLG44tGq1gitW5YrpPGumQsjDF4JnxxGGIThbq/HhPqw3Z7sUoj995pGbI3BaAo+6O/N+ly32l3h",
	"lj4uL53MCeA2mAg4uC4p67QEN9751QHuUUU8h1StcQxfaXcdDUbkR/DxzVcGxTWPI7LkCyPR/UhWMmck",
	"pyKRq1rszvfb2WjNHfGs6NG7UbJrKdsurXuWhs9kx8nYaje4u0bTMdfSPed6icpccfsiDZb2MqQaN+Kj",
	"9JxD59Z3ut1+mk1vHglKu5RZ/6a0Tu/4GIl7zYTiUkTODchG4R6enXQY37/OGP6l5u+AEGymVqU1pv4o",
	"WCcLMWirXnCyYeuKbRIM25EkGMS2JTtWBU3XTrre25oA1bSPzTJlLQxG8Ht4z1aarjKygxFQatfyQqPg",
	"lWu9o4qUgl/p7fb96Pne/sHzdnrcFoJ8SArBfy0Y4fBoPec2jgXjkCtQrtA78y1eZWmfzuK9/YM2Ured",
	"1agU9lvDN73M3JQhrEpt+ng9aFKXqSe9wOJS+9ZqRSmeoh59aleOtpTP3WSbbsWnLuHKbWLa9Qbzof5c",
	"yutY1Eok8DnyyaPaN852sqNpOu1+KtI0dYNhSJt9Ef2XYKltBK0G9erCoxYQ1ZbSBnbn19Ci45svBGLV",
	"ctBCyafzkwa96Q5wKzuRnc7Xkuprbnsz/s/XH8/vRv/+biG3CQ/tcjdp8+Do2HSoLAWuJpuktdpTmns2",
	"euxeefB7wlkqy+UgjyrI8DVq7VECAF1ou19gnZthC830Ls5x3fvQkiEf8j/BGMtJb7f6AOYiL7f243yS",
	"v5d/tdm0dlb3t9zu7WeDw1r7hzF/9cTV3+ucwivHpuW/O+Ufjs+Jb+yP4DeWy75aSnAK886aIMzFhdJy",
	"RVI6Y6nabQaEGVxeFYLr9XCRcsHyKe7kdn+wZ6PDGk3woDRVN0/bZalIbNqlbzU8PX3fdVAdOsnnLqXE",
	"7CPHCMrhO/vt44cPPz/VqdC5xk65mMtNHvQb1XA/DFzIEzNUw4P+DdOUp+BwXZpC6cx6/tn+pXe1c0eM",
	"aYayK2dqMBHvaVZ1V4VYJAzIEXM5IJ/AfR7Udq/sMHy8CIeaCPBoCGb24bE7iFsRMVhokDAiOUthvSoi",
	"VKg7lqvdhr93olK+GsLtBy/PD8fnGNFeTgqmeRi8d/XwOC529456bm09c4h2cb2oZ1fXPXx4G7Ya/6rV",
	"chT4VG9C/ebB1vE+dM6uIn4bPKPw15TmC/fzo3t94rWwjuab91b1P+8gsG6s/u1+f3Xw1HVY9/NN6+jy",
	"Sm9C2vmyV1earn5dDOcpFX39wlJ99WtBk/6vi15U/Qrn4D8+YStt2QjwnawEdcjyKqS1im0hVNpEAk+L",
	"joW2gbuNnFGbkirJ+Vwxl0GJwRhtyaGC4KTWhyFzj1oer3E8057snB2fR+Tj+buInH48isj7k4ujqux4",
	"BqjdND/FMmcdGZMwPwu0QIuPlqSZjuWHH7ax6YCn/lNBNWMLLip3YfS0zFN2HJtNqgTGv8mlIBcrHvqO",
	"bMqm4s7A7QOSUfUc9DZiTqfN1VLHJkhQJrFLx1YYiAyCDdmxgo69mVKk613nH1woQ0IoCZtEZC0LsG9h",
	"nok1oWLtIbPOWDh6NBEQ5WyGKeUmM5bzGkb2mDOdY/zPYCJs5EnVORnaPVM+8sxuBII4VSP4+XMvY7kC",
	"DRTUB7FGnSEpQGVOqGZPo3aPWHbrvGRrVtLBSZoPDpaPTruO+dw2aBwButCGJsdnnik/K8WOtY88AR3Z",
	"24RcOJaVP1xXNzo8GTv0cMJBRM6PXx+f7m48SzcCRLSVQgzh6CaC+R4axzq3QZFR707mN2oK1AE8Clgy",
	"5eJph9rhuXppfg4hCMjNGbKt6nrKm0/uMFxX23wZRnPGZBsnIh4QDpaMowJurJCDr+BQjzueBtSiS/t0",
	"e9rkFIZ3Gt2t6w5hZvJ2d7CthHHLAL/cN6zDUfmR67Npux61N2zY3ZHKo5yjkriUDVds4035AljiFF/s",
	"uOxRYCMK5Ud+/S3MpdwbOHjRJiV0pAM8lZF6jYmVNUIi8uH4fJf0S6oATVlCVEaFwpwaFaHEDOcUgXHp",
	"HU3zGdc5zT2ro2FSCUzqU+F4EFnpj2tMzlsonEvN5wlB50GawayeMybHdoRbiHNXNiGj+Qj2rfoYu0js",
	"rDlqa22qBd3bdN4WR4VOnbd5jM2Hj4py1vn6EbRCzbcTP2qCf1PXi55IYkLE3crjwF+oBrFcMgxPfSJp",
	"6xC0jSTpT3LJM2LNiUHeNM/lvljAdm8snqptkLhfbPWKSnn6ZBjUKA/A0Q4VyMAbpF6jgHW7GTwmlFWU",
	"4BaZzIVstzsU17TjzsCrjuC+nImE5SwJ8jI6wQJHHhDwqkw5JL5xubGVs3R7AiQWE0FFQnBAHmZ6nHOW",
	"Jmqo2SpLIWJvxubm9GOapj6GlYkkk1w0hakToVEktn6r9TgJNP+/gWQ19icyL0RCzdw0heyRTxK4fi1Y",
	"vm5LU0zzeEngKybqZim7pQ6Z6x7f9WUSmmUpjz1l3M7xG9dSnuEm/Ptjgqg8Pnbe63a5PgAFC8QSXHiE",
	"WR5sDj6FwkpFMHuqe34HvOwC28EERo/NkU6qK9QpuBUwzFDnVCiz6iq2XpqfDZabtu9YvqJiTFpSn/+h",
	"il27AWtL+9Uj5qvt8NQCbyPc/yj8NMM9LcoPl6CNsgjHuEOdOI1SdEQqUnSE0o7RisxvM0ZXG2PzNuhu",
	"X6khWQe+Fs4sU4axC84jSgHdxUCBOHAsC0Mt1kqzFTy4g4u/LzJgwy5apbR6THx75t/Wx9GGOLYhdXA9",
	"lLD1dGtvobWcv5ufQTsTBINXUotHCPiPer+pXVQdmr5TjU26Ho/6/jYDVYI9No8cTJ7WoSv0zgH/y4mf",
	"dtIzXNp7cu0G5+9Xti3MWjpU4QYeml2wA9fchsPoF8PLzefg1uXL86nDk8f6oTbjXsCvrduBZ8sTgd1u",
	"OpYvOwnub8KWx9Hh8H0i4pyhRBSsF5wxNnt/f+nxeCfq7c4I3Yghb0+urDN5eXDg795adOXxWJSw0It1",
	"00F6HHXGVm952C1L3v6QOw/wbQDw5jJ8rNQ24Wk0X4AE3sISISrLhg5bMPnWNuean6tyW36f+NgoDHpu",
	"xFZNeg9/QIQa7m/7ALW2yKgogMDVFiDf4u5U1rfN/dlwBuG4JfCDk9kejG4HCMsuzNwWC70XckN917lM",
	"FQiyJSfEfNpSpmpAMHMNmtEmPVpoaZAEnR0TFvOEKXJXBsEBEKllaWGe6ElPSMHKvuDoLaS2PcQaJ8Sm",
	"7tzL5qtCuabaZtc0Ep7pY7rgdsc2HzR1ucjjSnykDwGtVRBy19tsrhfBOnsB7l09HnK/3bQbKXH1yxcH",
	"f25xh7rjH3//JoLF1UPU+yfLFZeiW2WAzOqQyKslaR9mXXcuxBUKsj/af94f7fX3XlzujcYHo/Fo9H/b",
	"LtmC62ksV6u2KgrvOLgDr7gmS6qWlfFRinjeOqSc3uK2WoaUxHoiEdemGlWxN9h/MRi1Dds5pnOQbxvw",
	"dm8wahuudlhl1wAeUQj8yrbaMKWeIcy5CpZ5wv6qaPVXRatufOnI6t0WLLxoVI8CzuyzJmJuXtXAl5Td",
	"svRrs42fwiBwSuvHg+4eG+0CBmnlz9stpJLaEPwSow6A3bJ8ZlBmTRAOpfiasFmxANMOdL+jWC/LpYMo",
	"qYlt0CBN2+2yslR0NqRp53JlobNCWxdrAsAekGeuGxbXimUqc/4bJppWMmURefaLkuKZk9SKWBc5S0DS",
	"isizVC7mK41fsSIXm895DAbvG7b+ETJdk4zyXEXkmZAyc0W8Uib0IABZsPxf0K8DxwYxQWZVsAWNHwVd",
	"R2LFZmLBOGZKTW/YurX25eFPFwSbmI2RkzdBwqYbtlZa5oyotdD0HnfI4pxpkkp5U2QD8hZCQF05isOf",
	"LqaHR0fHFxfTfz/+j+nJG8LELc+lAJv/Lc05ONdxn6G1WqtsLYu8j4vp37B1n7eafNyrQAuNPQh97l07",
	"l7v0mToY0BX9TQp6pwaxXD0jMjdH7Wrk/DAajfAY33Nx8rHqNlbvDC7q4tTmiNtrTSRnIDUt4d8OfAvQ",
	"8gy+9gAujo/Ojy+Dc/iCQ8BJgrNoz5SnlA8i2ZCxEncJbfEy2ZR+mER+TYLsok/ae9uyYZY+rqg1holN",
	"lUofzbl0jBUuLi5Oh5enFzD3xYGhHQJruSivmowhGhVaHP50AeVZfML/mKYlKrWk7XiUkm9Z8KR557Hy",
	"xNSgtWor+sU1S+1Lt21LTFvICzw8OcO4+ZSLG5LIO0j8rSCxMltleh2B4xOMjYVO7AhGLGKZJlnOb6lm",
	"xIzD52SWyvhman+c8gwrmeUF2x1U30nsP+3tihMxqP6y98P+YDR4st+xA0ZG9XJbYJi2JMvZnN8zV60g",
	"ZePhENPIHJh/fTo/bQAF5giBMjAKpe9cKEboTMm00My2tcRp+EmxXA0TqulwFzvhLKbLrIhvmB7ielyP",
	"1bpvfy8yOKBhHZ7hmIZcNTo8DY6Nc3z0Fr02PSrlFkrUIDkVENq+t/+90TwGo+GriOyNgn9/vz/Yewl/",
	"7e1HxJz+3stX+PfLiOy9/GGw/+K5/Xu3NbjbIa/L7zy1oaOVlR80A4tt7mRz7lwk/JYnBU39VSAys4GZ",
	"4BrnxgyriYyAO/CVkQH2uipY+NUp/hubztaaVRe2N3r+6sX3L0edJS1MP4O1biBbRwPL0RAcsOJU7cfz",
	"ixs9omtwoV8+dwvGsLGErzC8upoiYfT8Vdc6oR+544leDpeML5awvozfQ1gS5vbzcfs5M9uq1uPDwTdB",
	"tElNHx6snGozblCMlkW7SO8QKG0vwrhEqJenxsPhgutlMTP0xgrkyWxo88A3Y2+cGoGVVWwid/D3QtJf",
	"em9BScXc1/W05V3fn5bVYCbib38jPy0p+FPYgcPaddYPVTmuchqMjiXH/AoCEejw7ATMbt99V9YQeOfD",
	"ir/7bkzgoQ3qupQ5GHeOTk/OdhthcDgQdHC1BcwIF2xFheZxGfIH6wnrl7qirX1AWFd6EcfzBQfMWKXP",
	"QM761oPCMn5wtMAqlXYlH+iKJc4hLyg/YAayDmwEnalVRGS+oIL/5uKNnLnalSlm9zrY3rl7TwYIuUd9",
	"VJnRZ9K9rrvQOu8lVwZtR9YtJPyF6XiAJQ0cKYFEWFQzqPWTMmoYhCYOHREHB1wOExmroefFHl8gFwxE",
	"Z7XgTEwFyQtIyi0SmkrBoI5wWeqDCoL3gMRpoTTLAVlOAcPK86thmiGM7F6zHES7sxNbLIiJGALA+i1o",
	"eD2kGceoyetSLK9mLod0sA6VytqhDgHOD9+RjGcs5QJnCVHFeUsBvV6ZqwLJdK1vDk25XpsuR0zonKag",
	"BloXPpbfgh9OnEulSMIN95tBYnMhE5zozLCseN0Hz1lsXrl9ELNsa6SkjN4yRYwsalrk1GuWu/bI3jJI",
	"HGJP8G+k7V4iJmIUrsHA8CpVyoi4Kq2dxUNwpMOzExhmu3Nx1xLtrATLcMI6XnNhxHVvlI9AW3Y7eV8S",
	"ECvDW0KCA2LAtN8uDGg+k6Ai1C+AF+bw+8gyShKkMhozOxI434TrgvBvH0WuyM51Zxz59a65A0Z0w8Fs",
	"qPaRB4oZ8JNiqpaJ1loXdq6/KAmwTfd7bWFh7usRVVBgkiBgEFsjAojYRzDmTOec3dI0IrdcGQlE8RVP",
	"aQ74jFCvkOM64rwtia6/TI26orvkX0IMC8Ygbyyerc1gh50FbDqr0OBYR1jF3Yyx38e6heTy8tSVSoOa",
	"udjyreUMsPaKXluv3OJcgOaUp/4ueVay7R7Ci9WykaAyDo74j8KQp9888zysVng0WPMrNimLtfF5CeoA",
	"f033iq8lkDzr0kd2rG/lkookNQoIZ2kS+HWjw3XKY2afQpxUk6bk3MhXipwzrOPcEHFKnpKyBcXkO1xj",
	"kvyy7n8veEbo3e7RNFvSPcg7gppob9w7GIwGB72o5/UqPHnQRqVqM89kKde2NkNLSW/LWpVjAlWpoZZQ",
	"wIlM7y3SIgYAwpeVj5q4jknHG4X2ocy4LusSY4170/iTq8Pzo09YYH5+SxWKTZXMT24ZgFfv/XVqSki+",
	"6JgjMuHF7pP3m2h94LxXvWlPvjHE3kzz1zlKVqC6wo0M6zsa2rzvSo4OoBsDa6HP5jCTemkN7QAWHfhv",
	"uaOyVXXNX9fX178ow+h+nwhSybbeURkeCGiEjXEaJLGCEPMTbA0HsIcUuU+V0v+myYvRyH+0B1356j8q",
	"llEIlsWBJxNh/uuZzw8T8QC7wHdgpw6eJK4o+SU+cljV97VM1rXEf4Hn7/AXmxUSnwK2KpLuPFYfqk8s",
	"RgmHH5B5w63cH43+6LntEyxM3ua3B2iZEFWA+XBepCkYEJ7/gSvB9NYtKzgRkCzXWR3MvC/+nHmtSGx1",
	"PWYbRj1VrFY0XzvUaKF/ii3QHcQ0H2JdlW4y6hIghfoIlIj3dVpcZRYgGFmlXE9ZoMRVVbE8Z2Cr9GFt",
	"X7WxfA8+qdjwXC+icfELGkchoHCeyrsWKt1H4apca4X9tjomX6Ob5ZLeljVnypNBXcDWK7efB1KIe0ue",
	"4Yc+F1zjr3OeOumbeDlsIkLlVgrNReG5fBXecfBVOQgDBOuK9omwHBQ121gK1AZwHOhZVX++++5dwROW",
	"1FT0xvyYSsQyEBckjXDBtzA72lEgS24aEpZyy8E+H64opNpkB5/bYau7bTQ8oMGt9X88/cYxHLlvK8tj",
	"iKyjry2LCGr8fNVCgr32xuTz59FgLyKjAb7CX0Xk82hwYH54jj9cbSD6WLTmG1L9avWwP5ns10rydNF9",
	"vGz/dej+89Hzbz+vLagoNYHYN0hnJhkWoLUe12URov9kZmRmP/j2syO6OO8KUgSVj3eEDEuI2UDWGpu0",
	"/dvIpGV3nn0gx8TogEcZprI1QsLx0MQfFi7CGdKaESzgj9Z8xVW4E7R5goXlmaoaVqzpwJUxizAmDpKU",
	"JpA1APs2csYFFlmHSGaMwGjSZK/vy5Khj2oPYZHZsiKprUxpBArcBfYI7HZaQur+UqsKV+O4aB/cTVfW",
	"FOHerNrzoO2OyWEML4dhvSGrxJdAqA8GxqVqVwNY+5xwy2lpEbJwqliOsC5xUJEKoOaDJL5pfaq2sq/d",
	"Nau2KlOFJqZvU6SqJaPh7leqkL5OuXX4j8HeZR8KzQgJSwqkTCyZCGsagOOYp/CChPV0ofRBzpJCJFRo",
	"kDzdraibMM3P3rvAR3P5ICPIPmKwxiIU1mTH4swhkZSxZrqPzt3X3iiqWM5pam1D3kQakZVUmnjfod3G",
	"aIbkXo/RwdvxbyQIQTI2oBcdghniscG6MAFlA7vGG+WkrqK+VlACAgkyUg33DVLVg1onvatQenvfWoy1",
	"iU+bF7ip4m/bMkGFf/TOUJItpZYYNBdTbS5QS9evu0U2K6m9TGb4TYKk41WlofwbCZSVEn9/sjxZrTFm",
	"5u66YNUxa94FcPP67uaF2q0rBhYm5p5B8xYf1Yb8UsI+rM34P1io/S9lRPG6a1AADaRAX39hC0EwMJ2g",
	"pBckEbXiBUiY5GB3MBFvzaE3pD0jItnE8kdLqsmRT6usyOHZydcJZ0Hm0j9QOvvb34gvJgTskGlyjTcN",
	"/diuMZwdS4ZfwCH0Lwx7PIYKClBvaBe3z8tIpYlAtz6swDAgxzRe2qpE4HnBhSKUXBsolUACY9i1jbvB",
	"mvc2ZAqd7GESfMgjn998/HB8dT1okePMT2BS6siFb6VvZKmungb4NI23MR1UMsR6TuMGqjKbXKaWY2BU",
	"NbILe2Pww3/IAs+fLFmazYuU+IDrQYX7lGMViuUtI0H+gP816SFHcevy5UtMo/0XL+3vCFfzG7gndllX",
	"PkjR91FrzrYyo2o5MdJaSvo/k7OPF5fgnjAeDkvP2VejVyNAR191ejIxM/f/TiaufHv/cp2xMalTjUnP",
	"tU3IszaD/oaDaBzFNoBzTjZ1ueVfJ72Hq3LYCiT3RiMw+z9rBdvFf3eQeVwr4VNilCEbFeB0yjRHPkzk",
	"Wwg09do+f7JM0yjW8WADZ4ZACFvlma0LsbXxyqOOSh8Dcs50kQsbNWoULxHea69mRRMh8zYiX62Z5bWy",
	"nZBRQOK3v8Sg/47mu3dBadYOE56VlMqKP7tdQlogaBkRq0XxQ+HNZnse/95bMN2WrQVR2og2CvS1Zrb+",
	"yL92R6VPWFQmio/Ih+PziGBCqkpWZ/9C7SxiaMlquoe0W89M2394vw8IsDDXCB6srvv81TVRxXzO753J",
	"xL7a4ySHXXURyM6s4KnucwFWg7O0UBDkvHFVoUeANYJYH5YttlTzdzleZXqNYSLNA7fDv/NiKo5fz8Xf",
	"JdJuO36ZE2+7DZS5amGKEwfVaqpgQ+BaiyH4We3bI85Zc/bc9FRpml++iMjb08MPffOP14fnl4hzp+//",
	"8Y60+Il6v6uKghDoBkb6t/fQagEwHprYBi389pQr/d5lT/9mDK9WJaSLfCrnxvafpUO/pv81nQFO27Q0",
	"JIYej7tVWX8xFJgIkyDD56M+z9YPuXR9tgQa7lZYGqRGHdHT2sikaEsFt+I8IUfyw+lpJZG2dTo/Oz4H",
	"PzdYEKzTa9eTIAHxpGf9Ij+evwNH1XDdZQfMToziaZmf2Hc+/XhkOp96z27f8QO7I/8h8xvsCnlJmO/2",
	"/uQC+r3nKmZpSgWThfLQbPFfeIoW3yBI3v78a5Nf7EDHKX8FjgqwvKOayeHvBYS8vqUxI6+Pzy+t+1rz",
	"zEznKs1zT0hxW1b1W07RpoB/X5elpx/33Qr0jpaU4F5lhoxm1oa8Ifd0/Xgb6acr5uUG6avm8eTsW1lP",
	"G1nt/2Rto5knu82O6UiCdRz9y4r5P0F8DyJhvlx+9/hV4y6OPxlBcRNz6tucn1mni7N3gS1TpmpJqA2a",
	"qTCkakUYx46O0EX63OWe9SWI0JRoPahXhdLjidgb+JAgO59LQYtE2/mZqonYNwo05E2ElEIuQe1EHAzI",
	"BRNJy57sey+hilzb/V3jOrgiCVN8IcgNY5kqM09oqlnKlAJRDmJFlV0yxEkilTbwL3PnpnLB48FXc6SK",
	"jN/Cj5wVHHtN/QfgShjBUPV7z3I2Z3krS6s6vz+Bk3SkMvbcBLAEm25MqltzOgsNtpNGFuH3dqRTO9KY",
	"wAEuCp4wgiEDpR+yGQASDLvW5G2QYHhMPrAipykRTFsWlzPoXHsAnIi34DGE6Of5uUN54Pp17/8IgoK1",
	"R/K+4gmbiOuUz4a+q+Hh8Q3EXS55vPShBCU+PZ5xuc5bzdBnNuvwt+KrYd7sP52pVpImt9BWu3l7QH/x",
	"0/8Z/NRdxq/gpmaIkvWtS6bnGCpYEDZx1FqG6U3BqC0GCFD4vp53VOwctWnB3GX9kIFXRE3v6yh0yq74",
	"Yzd1nS3sJW0u3P9wPTo8nt2IlvFjMYo+oJCRTijPlR8oX3eNosrE7668TihDgPJLc5otc6p8bDNAz7n/",
	"k4TPIYQUnJYSF11tU4W76Owyc7jp5ap5pFQsCnjBafBUw03agFaCFMG3+fFzQ/rvqreN0+gWdfCOyaQY",
	"jQ7iZQr/Z+Q1W0sj5HX8rDTNwdilyLHWlPwbGAuM5kcTnqY0BlNgnqhHFUCA8jf0xK7ljP/TeVQ1c3qX",
	"L3bu05v/xaL+erHZikcF5KmNryCnCnJLbnyoqaWajMjCp8iMyMyn40SG0Mx1OWh5RNb/9Lknv9n1qmcZ",
	"bQG2bRImnPzPsWXXHty0g111ZdAMkFJBqtr2FCaHZycWdX288JBmvPdw9fD/AwAA///vqN0R3MEAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/chunking/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/logging/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/s3/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef3.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/scraping/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
