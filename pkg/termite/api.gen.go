//go:build go1.22

// Package termite provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package termite

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/antflydb/antfly-go/libaf/chunking"
	externalRef1 "github.com/antflydb/antfly-go/libaf/logging"
	externalRef2 "github.com/antflydb/antfly-go/libaf/s3"
	externalRef3 "github.com/antflydb/antfly-go/libaf/scraping"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConfigModelStrategies.
const (
	ConfigModelStrategiesBounded ConfigModelStrategies = "bounded"
	ConfigModelStrategiesEager   ConfigModelStrategies = "eager"
	ConfigModelStrategiesLazy    ConfigModelStrategies = "lazy"
)

// Defines values for ImageURLContentPartType.
const (
	ImageURLContentPartTypeImageUrl ImageURLContentPartType = "image_url"
)

// Defines values for TextContentPartType.
const (
	TextContentPartTypeText TextContentPartType = "text"
)

// Chunk A chunk of text with position information.
type Chunk = externalRef0.Chunk

// ChunkConfig Configuration for chunking requests to Termite API.
// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
// which includes provider selection and caching configuration.
type ChunkConfig struct {
	// MaxChunks Maximum number of chunks to return
	MaxChunks int `json:"max_chunks,omitempty,omitzero"`

	// Model The chunking model to use. Either 'fixed' for simple token-based chunking, or a model name from models/chunkers/{name}/.
	Model string `json:"model,omitempty,omitzero"`

	// OverlapTokens Number of overlapping tokens between chunks
	OverlapTokens int `json:"overlap_tokens,omitempty,omitzero"`

	// Separator Text separator for fixed chunking
	Separator string `json:"separator,omitempty,omitzero"`

	// TargetTokens Target number of tokens per chunk
	TargetTokens int `json:"target_tokens,omitempty,omitzero"`

	// Threshold Confidence threshold for ONNX models (0.0-1.0)
	Threshold float32 `json:"threshold,omitempty,omitzero"`
}

// ChunkRequest defines model for ChunkRequest.
type ChunkRequest struct {
	// Config Configuration for chunking requests to Termite API.
	// This is a simplified config for the HTTP API - differs from the full ChunkerConfig
	// which includes provider selection and caching configuration.
	Config ChunkConfig `json:"config,omitempty,omitzero"`

	// Text Text to chunk
	Text string `json:"text"`
}

// ChunkResponse defines model for ChunkResponse.
type ChunkResponse struct {
	// CacheHit Whether result was served from cache
	CacheHit bool `json:"cache_hit"`

	// Chunks Array of text chunks
	Chunks []Chunk `json:"chunks"`

	// Model Chunking model actually used (may differ from requested if fallback occurred)
	Model string `json:"model"`
}

// Config defines model for Config.
type Config struct {
	// ApiUrl URL of the Termite embedding/chunking service
	ApiUrl string `json:"api_url"`

	// BackendPriority Backend priority order for model loading with optional device specifiers.
	// Format: `backend` or `backend:device` where device defaults to `auto`.
	//
	// Termite tries entries in order and uses the first available backend+device
	// combination that supports the model.
	//
	// **Backends** (depend on build tags):
	// - `go` - Pure Go inference (always available, CPU only, slowest)
	// - `onnx` - ONNX Runtime (requires -tags="onnx,ORT", fastest)
	// - `xla` - GoMLX XLA (requires -tags="xla,XLA", TPU/CUDA/CPU)
	//
	// **Devices**:
	// - `auto` - Auto-detect best available (default)
	// - `cuda` - NVIDIA CUDA GPU
	// - `coreml` - Apple CoreML (macOS only, used by ONNX)
	// - `tpu` - Google TPU (used by XLA)
	// - `cpu` - Force CPU only
	//
	// **Examples**:
	// - `["onnx", "xla", "go"]` - Try backends with auto device detection
	// - `["onnx:cuda", "xla:tpu", "onnx:cpu", "go"]` - Prefer GPU, fall back to CPU
	// - `["onnx:coreml", "go"]` - macOS with CoreML acceleration
	BackendPriority []string                           `json:"backend_priority,omitempty,omitzero"`
	ContentSecurity externalRef3.ContentSecurityConfig `json:"content_security,omitempty,omitzero"`

	// KeepAlive How long to keep models loaded in memory after last use (Ollama-compatible).
	// Models are automatically unloaded after this duration of inactivity.
	// Use Go duration format: "5m" (5 minutes), "1h" (1 hour), "0" (never unload, eager loading).
	// When set to "0" or omitted, models are loaded eagerly at startup and never unloaded (legacy behavior).
	KeepAlive string `json:"keep_alive,omitempty,omitzero"`

	// Log Logging configuration for Termite services
	Log externalRef1.Config `json:"log,omitempty,omitzero"`

	// MaxConcurrentRequests Maximum number of concurrent inference requests allowed.
	// Additional requests will be queued up to max_queue_size.
	// Set to 0 for unlimited (default).
	MaxConcurrentRequests int `json:"max_concurrent_requests,omitempty,omitzero"`

	// MaxLoadedModels Maximum number of models to keep loaded in memory simultaneously.
	// When this limit is reached, the least recently used model is unloaded (LRU eviction).
	// Set to 0 for unlimited (default). Only effective when keep_alive is non-zero.
	MaxLoadedModels int `json:"max_loaded_models,omitempty,omitzero"`

	// MaxMemoryMb Maximum memory (in MB) to use for loaded models.
	// When this limit is approached, least recently used models are unloaded.
	// Set to 0 for unlimited (default). This is an advisory limit - actual memory
	// usage depends on model sizes and may temporarily exceed this value.
	// Works alongside max_loaded_models for fine-grained control.
	MaxMemoryMb int `json:"max_memory_mb,omitempty,omitzero"`

	// MaxQueueSize Maximum number of requests to queue when max_concurrent_requests is reached.
	// When the queue is full, new requests receive 503 Service Unavailable with Retry-After header.
	// Set to 0 for unlimited queue (default). Only effective when max_concurrent_requests > 0.
	MaxQueueSize int `json:"max_queue_size,omitempty,omitzero"`

	// ModelStrategies Per-model loading strategy overrides. Maps model names to their loading strategy.
	// Models not in this map use the default strategy based on keep_alive:
	// - If keep_alive="0" (default): eager loading (load at startup, never unload)
	// - If keep_alive>0: lazy loading (load on demand, unload after idle)
	//
	// When a model has strategy "eager" in this map:
	// - It is loaded at startup (as part of preload)
	// - It is never unloaded, even when keep_alive>0 (pinned in memory)
	//
	// This allows mixing eager and lazy models in the same pool.
	ModelStrategies map[string]ConfigModelStrategies `json:"model_strategies,omitempty,omitzero"`

	// ModelsDir Base directory containing model subdirectories. Termite auto-discovers models from:
	// - `{models_dir}/embedders/` - Embedding models (ONNX)
	// - `{models_dir}/chunkers/` - Chunking models (ONNX)
	// - `{models_dir}/rerankers/` - Reranking models (ONNX)
	// - `{models_dir}/recognizers/` - Recognition models (ONNX)
	// - `{models_dir}/questionators/` - Question generation models (ONNX)
	//
	// Defaults to ~/.termite/models (set via viper). If not set, only built-in fixed chunking is available.
	ModelsDir string `json:"models_dir,omitempty,omitzero"`

	// Preload List of model names to preload at startup (Ollama-compatible).
	// These models are loaded immediately when Termite starts, avoiding first-request latency.
	// Model names should match those in models_dir/embedders/ (e.g., "bge-small-en-v1.5").
	// Only effective when keep_alive is non-zero (lazy loading mode).
	Preload []string `json:"preload,omitempty,omitzero"`

	// RequestTimeout Maximum time to wait for a request to complete, including queue wait time.
	// Use Go duration format: "30s", "1m", "0" (no timeout, default).
	// Requests exceeding this timeout receive 504 Gateway Timeout.
	RequestTimeout string                   `json:"request_timeout,omitempty,omitzero"`
	S3Credentials  externalRef2.Credentials `json:"s3_credentials,omitempty,omitzero"`
}

// ConfigModelStrategies defines model for Config.ModelStrategies.
type ConfigModelStrategies string

// ContentPart A content part for multimodal embedding (text or image)
type ContentPart struct {
	union json.RawMessage
}

// EmbedRequest defines model for EmbedRequest.
type EmbedRequest struct {
	// Input Input content to embed. Supports three formats:
	// - Single text string: `"hello world"`
	// - Array of text strings: `["hello", "world"]`
	// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
	Input EmbedRequest_Input `json:"input"`

	// Model Name of the embedder model from models_dir/embedders/
	Model string `json:"model"`

	// Truncate Truncate input to fit model context length
	Truncate bool `json:"truncate,omitempty,omitzero"`
}

// EmbedRequestInput0 Single text string (backward compatible)
type EmbedRequestInput0 = string

// EmbedRequestInput1 Array of text strings (backward compatible)
type EmbedRequestInput1 = []string

// EmbedRequestInput2 Array of multimodal content parts (text or images)
type EmbedRequestInput2 = []ContentPart

// EmbedRequest_Input Input content to embed. Supports three formats:
// - Single text string: `"hello world"`
// - Array of text strings: `["hello", "world"]`
// - Array of content parts (multimodal): `[{"type": "text", "text": "hello"}, {"type": "image_url", "image_url": {"url": "data:image/png;base64,..."}}]`
type EmbedRequest_Input struct {
	union json.RawMessage
}

// EmbedResponse defines model for EmbedResponse.
type EmbedResponse struct {
	// Embeddings Array of embedding vectors (one per input string)
	Embeddings [][]float32 `json:"embeddings"`

	// Model Model used for embedding
	Model string `json:"model"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// ImageURL Image URL or data URI
type ImageURL struct {
	// Url URL or data URI (data:image/png;base64,...)
	Url string `json:"url"`
}

// ImageURLContentPart Image content for embedding (OpenAI-compatible format)
type ImageURLContentPart struct {
	// ImageUrl Image URL or data URI
	ImageUrl ImageURL                `json:"image_url"`
	Type     ImageURLContentPartType `json:"type"`
}

// ImageURLContentPartType defines model for ImageURLContentPart.Type.
type ImageURLContentPartType string

// ModelsResponse defines model for ModelsResponse.
type ModelsResponse struct {
	// Chunkers Available chunking models (always includes "fixed")
	Chunkers []string `json:"chunkers"`

	// Embedders Available embedding models from models_dir/embedders/
	Embedders []string `json:"embedders"`

	// Extractors Available GLiNER extractor models (zero-shot recognition with custom labels)
	Extractors []string `json:"extractors,omitempty,omitzero"`

	// Questionators Available Seq2Seq questionator models from models_dir/questionators/
	Questionators []string `json:"questionators"`

	// Recognizers Available recognizer models from models_dir/recognizers/
	Recognizers []string `json:"recognizers"`

	// Relators Available REBEL relator models from models_dir/relators/
	Relators []string `json:"relators"`

	// Rerankers Available reranking models
	Rerankers []string `json:"rerankers"`
}

// QuestionGenerateRequest defines model for QuestionGenerateRequest.
type QuestionGenerateRequest struct {
	// Inputs Input texts to generate from
	Inputs []string `json:"inputs"`

	// Model Name of Seq2Seq questionator model from models_dir/questionators/
	Model string `json:"model"`
}

// QuestionGenerateResponse defines model for QuestionGenerateResponse.
type QuestionGenerateResponse struct {
	// Model Name of model used for generation
	Model string `json:"model"`

	// Texts Generated texts (array of arrays, one per input, multiple per beam)
	Texts [][]string `json:"texts"`
}

// RecognizeEntity defines model for RecognizeEntity.
type RecognizeEntity struct {
	// End Character offset where entity ends (exclusive)
	End int `json:"end"`

	// Label Entity type (PER, ORG, LOC, MISC)
	Label string `json:"label"`

	// Score Confidence score (0.0 to 1.0)
	Score float32 `json:"score"`

	// Start Character offset where entity begins
	Start int `json:"start"`

	// Text The entity text
	Text string `json:"text"`
}

// RecognizeRequest defines model for RecognizeRequest.
type RecognizeRequest struct {
	// Labels Custom entity labels to extract (GLiNER models only).
	// When using a GLiNER model, you can specify any entity types to extract,
	// enabling zero-shot NER without model retraining.
	// If not provided, the model's default labels are used.
	Labels []string `json:"labels,omitempty,omitzero"`

	// Model Name of recognizer model from models_dir/recognizers/
	Model string `json:"model"`

	// Texts Texts to extract entities from
	Texts []string `json:"texts"`
}

// RecognizeResponse defines model for RecognizeResponse.
type RecognizeResponse struct {
	// Entities Array of entity arrays (one per input text)
	Entities [][]RecognizeEntity `json:"entities"`

	// Model Name of model used for NER
	Model string `json:"model"`
}

// RelateRequest defines model for RelateRequest.
type RelateRequest struct {
	// Model Name of relator model from models_dir/relators/
	Model string `json:"model"`

	// Texts Input texts to extract relations from
	Texts []string `json:"texts"`
}

// RelateResponse defines model for RelateResponse.
type RelateResponse struct {
	// Model Name of model used for relation extraction
	Model string `json:"model"`

	// Relations Array of relation arrays (one per input text)
	Relations [][]RelationTriplet `json:"relations"`
}

// RelationTriplet defines model for RelationTriplet.
type RelationTriplet struct {
	// Object Object entity of the relation
	Object string `json:"object"`

	// Relation Relationship type
	Relation string `json:"relation"`

	// Score Confidence score (0.0-1.0)
	Score float32 `json:"score,omitempty,omitzero"`

	// Subject Subject entity of the relation
	Subject string `json:"subject"`
}

// RerankRequest defines model for RerankRequest.
type RerankRequest struct {
	// Model Name of reranking model from models_dir/rerankers/
	Model string `json:"model"`

	// Prompts Pre-rendered document texts to rerank. The client is responsible for extracting
	// and rendering document fields/templates before calling this endpoint.
	Prompts []string `json:"prompts"`

	// Query Search query for relevance scoring
	Query string `json:"query"`
}

// RerankResponse defines model for RerankResponse.
type RerankResponse struct {
	// Model Name of model used for reranking
	Model string `json:"model"`

	// Scores Relevance scores (one per prompt, same order as input)
	Scores []float32 `json:"scores"`
}

// TextContentPart Text content for embedding
type TextContentPart struct {
	// Text Text content to embed
	Text string              `json:"text"`
	Type TextContentPartType `json:"type"`
}

// TextContentPartType defines model for TextContentPart.Type.
type TextContentPartType string

// VersionResponse defines model for VersionResponse.
type VersionResponse struct {
	// BuildTime Build timestamp
	BuildTime string `json:"build_time"`

	// GitCommit Git commit hash
	GitCommit string `json:"git_commit"`

	// GoVersion Go runtime version
	GoVersion string `json:"go_version"`

	// Version Termite version
	Version string `json:"version"`
}

// ChunkTextJSONRequestBody defines body for ChunkText for application/json ContentType.
type ChunkTextJSONRequestBody = ChunkRequest

// GenerateEmbeddingsJSONRequestBody defines body for GenerateEmbeddings for application/json ContentType.
type GenerateEmbeddingsJSONRequestBody = EmbedRequest

// GenerateQuestionsJSONRequestBody defines body for GenerateQuestions for application/json ContentType.
type GenerateQuestionsJSONRequestBody = QuestionGenerateRequest

// RecognizeEntitiesJSONRequestBody defines body for RecognizeEntities for application/json ContentType.
type RecognizeEntitiesJSONRequestBody = RecognizeRequest

// ExtractRelationsJSONRequestBody defines body for ExtractRelations for application/json ContentType.
type ExtractRelationsJSONRequestBody = RelateRequest

// RerankPromptsJSONRequestBody defines body for RerankPrompts for application/json ContentType.
type RerankPromptsJSONRequestBody = RerankRequest

// AsTextContentPart returns the union data inside the ContentPart as a TextContentPart
func (t ContentPart) AsTextContentPart() (TextContentPart, error) {
	var body TextContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContentPart overwrites any union data inside the ContentPart as the provided TextContentPart
func (t *ContentPart) FromTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContentPart performs a merge with any union data inside the ContentPart, using the provided TextContentPart
func (t *ContentPart) MergeTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageURLContentPart returns the union data inside the ContentPart as a ImageURLContentPart
func (t ContentPart) AsImageURLContentPart() (ImageURLContentPart, error) {
	var body ImageURLContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageURLContentPart overwrites any union data inside the ContentPart as the provided ImageURLContentPart
func (t *ContentPart) FromImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageURLContentPart performs a merge with any union data inside the ContentPart, using the provided ImageURLContentPart
func (t *ContentPart) MergeImageURLContentPart(v ImageURLContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmbedRequestInput0 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput0
func (t EmbedRequest_Input) AsEmbedRequestInput0() (EmbedRequestInput0, error) {
	var body EmbedRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput0 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput0
func (t *EmbedRequest_Input) FromEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput0 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput0
func (t *EmbedRequest_Input) MergeEmbedRequestInput0(v EmbedRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput1 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput1
func (t EmbedRequest_Input) AsEmbedRequestInput1() (EmbedRequestInput1, error) {
	var body EmbedRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput1 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput1
func (t *EmbedRequest_Input) FromEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput1 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput1
func (t *EmbedRequest_Input) MergeEmbedRequestInput1(v EmbedRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbedRequestInput2 returns the union data inside the EmbedRequest_Input as a EmbedRequestInput2
func (t EmbedRequest_Input) AsEmbedRequestInput2() (EmbedRequestInput2, error) {
	var body EmbedRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbedRequestInput2 overwrites any union data inside the EmbedRequest_Input as the provided EmbedRequestInput2
func (t *EmbedRequest_Input) FromEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbedRequestInput2 performs a merge with any union data inside the EmbedRequest_Input, using the provided EmbedRequestInput2
func (t *EmbedRequest_Input) MergeEmbedRequestInput2(v EmbedRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbedRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmbedRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Chunk text into smaller segments
	// (POST /chunk)
	ChunkText(w http.ResponseWriter, r *http.Request)
	// Generate embeddings
	// (POST /embed)
	GenerateEmbeddings(w http.ResponseWriter, r *http.Request)
	// List available models
	// (GET /models)
	ListModels(w http.ResponseWriter, r *http.Request)
	// Generate questions
	// (POST /questionate)
	GenerateQuestions(w http.ResponseWriter, r *http.Request)
	// Recognize named entities
	// (POST /recognize)
	RecognizeEntities(w http.ResponseWriter, r *http.Request)
	// Extract relations from text
	// (POST /relate)
	ExtractRelations(w http.ResponseWriter, r *http.Request)
	// Rerank prompts by relevance
	// (POST /rerank)
	RerankPrompts(w http.ResponseWriter, r *http.Request)
	// Get version information
	// (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ChunkText operation middleware
func (siw *ServerInterfaceWrapper) ChunkText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChunkText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateEmbeddings operation middleware
func (siw *ServerInterfaceWrapper) GenerateEmbeddings(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateEmbeddings(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModels operation middleware
func (siw *ServerInterfaceWrapper) ListModels(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModels(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GenerateQuestions operation middleware
func (siw *ServerInterfaceWrapper) GenerateQuestions(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GenerateQuestions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RecognizeEntities operation middleware
func (siw *ServerInterfaceWrapper) RecognizeEntities(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RecognizeEntities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExtractRelations operation middleware
func (siw *ServerInterfaceWrapper) ExtractRelations(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExtractRelations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RerankPrompts operation middleware
func (siw *ServerInterfaceWrapper) RerankPrompts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RerankPrompts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVersion(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/chunk", wrapper.ChunkText)
	m.HandleFunc("POST "+options.BaseURL+"/embed", wrapper.GenerateEmbeddings)
	m.HandleFunc("GET "+options.BaseURL+"/models", wrapper.ListModels)
	m.HandleFunc("POST "+options.BaseURL+"/questionate", wrapper.GenerateQuestions)
	m.HandleFunc("POST "+options.BaseURL+"/recognize", wrapper.RecognizeEntities)
	m.HandleFunc("POST "+options.BaseURL+"/relate", wrapper.ExtractRelations)
	m.HandleFunc("POST "+options.BaseURL+"/rerank", wrapper.RerankPrompts)
	m.HandleFunc("GET "+options.BaseURL+"/version", wrapper.GetVersion)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Czb48unL/w8AAP//A+TtbKuLAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/chunking/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef1.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/logging/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef2.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/s3/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	for rawPath, rawFunc := range externalRef3.PathToRawSpec(path.Join(path.Dir(pathToFile), "../../../antfly-go/libaf/scraping/openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
